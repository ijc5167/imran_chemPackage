from __future__ import print_function, division

def compile_target(target, clean=False, silent=False):
    '''\
    :py:func:`compile_target` is a function to call make for a specific
    target from within python code. :py:func:`compile_target` assumes
    that it is being called in the directory containing the Makefile.
 
    :argument target:
        The target to make for.  If left empty ('') then it will make all.
    :type target: str
    :keyword silent:
        By default, :py:func:`compile_target` is not silent and will
        display all output generated by make.  If *silent* is set to
        :py:const:`True`, output will be suppressed.
    :type silent: bool, optional
    :rtype: None
    :exception:
        :py:exc:`ImportError`: The target cannot be compiled.
    '''
    from subprocess import call
    from os import devnull

    if clean:
        command = ['make clean', target]
        if silent:
            with open(devnull, 'w') as dev_null:
                retcode = call(command, stdout=dev_null, stderr=dev_null)
        else:
            print('Calling command:', ' '.join(command))
            retcode = call(command)
    command = ['make', target]
    if silent:
        with open(devnull, 'w') as dev_null:
            retcode = call(command, stdout=dev_null, stderr=dev_null)
    else:
        print('Calling command:', ' '.join(command))
        retcode = call(command)
    if retcode:
        raise ImportError ('Error compiling '+target)


def compile_on_fly(dirname, target, clean=False, silent=True):
    '''\
    :py:func:`compile_on_fly` is a function to call make for a specific
    target from within python code if it does not already exist.
    This is useful for distributing packages that you don't want the
    end user to have to compile (assuming that the make step is fast
    and easy).
 
    :argument dirname:
        The name of the module.  The function will search your PYTHONPATH
        for this module name, then run make inside it.
    :type dirname: str
    :argument target:
        The target to make for.  If left empty ('') then it will make all.
    :type target: str
    :keyword silent:
        By default, :py:func:`compile_on_fly` is not silent and will
        display all output generated by make.  If *silent* is set to
        :py:const:`True`, output will be suppressed.
    :type silent: bool, optional
    :rtype: None
    :exception:
        * :py:exc:`ImportError`: The dirname cannot be found.
        * :py:exc:`ImportError`: The target cannot be compiled.
    '''
    from os import environ, pathsep, curdir, chdir
    from os.path import exists, isdir
    from os.path import join as path_join
    from .files import abs_file_path

    # Search your pythonpath for folder where the files are kept
    try:
        pythonpath = environ['PYTHONPATH'].split(pathsep)
        location = ''
        for p in pythonpath:
            temp = path_join(p, dirname)
            # If it exists and is a directory, then save it
            if exists(temp) and isdir(temp):
                location = path_join(p, dirname)
                break
    except KeyError:
        location = ''


    if not location:
        # try the default anaconda install directory
        import glob
        condapath = environ['CONDA_PREFIX']
        temp = glob.glob(path_join(condapath,'lib/python*'))
        condapath = path_join(temp[0],'site-packages')
        temp = path_join(condapath, dirname)

        # If it exists and is a directory, then save it
        if exists(temp) and isdir(temp):
            location = path_join(condapath, dirname)
        else:
            raise ImportError ('Cannot find '+dirname)

    # Store the current directory then change to f2py directory
    d = abs_file_path(curdir)
    chdir(location)

    # Compile the module
    compile_target(target, clean, silent)

    # Change back to starting directory
    chdir(d)
